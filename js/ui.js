// ui.js - Manages user interface for Web Audio Instrument

class UI {
    constructor() {
        // Core UI elements
        this.elements = {
            // Transport controls
            playButton: document.getElementById('playButton'),
            stopButton: document.getElementById('stopButton'),
            tempoSlider: document.getElementById('tempoSlider'),
            tempoValue: document.getElementById('tempoValue'),

            // File loading
            dropZone: document.getElementById('dropZone'),
            audioFileInput: document.getElementById('audioFileInput'),
            sampleList: document.getElementById('sampleList'),

            // Layer controls
            splitLayersBtn: document.getElementById('splitLayersBtn'),
            layerControls: document.getElementById('layerControls'),

            // Effects controls
            filterFreqSlider: document.getElementById('filterFreq'),
            filterFreqValue: document.getElementById('filterFreqValue'),
            reverbLevelSlider: document.getElementById('reverbLevel'),
            reverbValue: document.getElementById('reverbValue'),
            delayTimeSlider: document.getElementById('delayTime'),
            delayTimeValue: document.getElementById('delayTimeValue'),

            // Sequencer
            sequencerGrid: document.getElementById('sequencerGrid'),
            clearSequencerBtn: document.getElementById('clearSequencerBtn'),
            stepsSelect: document.getElementById('stepsSelect'),

            // Visualization
            visualizer: document.getElementById('visualizer')
        };

        // Event callbacks
        this.callbacks = {
            onPlay: null,
            onStop: null,
            onTempoChange: null,
            onFilesDrop: null,
            onFilesSelect: null,
            onSamplePreview: null,
            onSplitLayers: null,
            onLayerSolo: null,
            onLayerMute: null,
            onLayerVolumeChange: null,
            onFilterChange: null,
            onReverbChange: null,
            onDelayChange: null,
            onSequencerCellToggle: null,
            onSequencerClear: null,
            onStepsChange: null
        };

        // State
        this.isPlaying = false;
        this.currentStep = 0;
        this.totalSteps = 16;
        this.loadedSamples = {};

        // Create containers for new UI elements
        this.createAdditionalUIContainers();
    }

    /**
     * Initialize the UI
     */
    initialize() {
        this.setupEventListeners();
        this.initSequencerGrid();
        return this;
    }

    /**
     * Create additional UI containers for new features
     */
    createAdditionalUIContainers() {
        // Create video player container
        const videoPlayerSection = document.createElement('section');
        videoPlayerSection.className = 'video-player';
        videoPlayerSection.innerHTML = `
            <h2>Video Player</h2>
            <div class="video-container">
                <video id="videoPlayer" controls></video>
            </div>
            <div class="video-controls">
                <div class="loop-controls">
                    <label>Loop Points:</label>
                    <div class="loop-sliders">
                        <div>
                            <label for="loopStartSlider">Start: <span id="loopStartValue">0.00</span>s</label>
                            <input type="range" id="loopStartSlider" min="0" max="100" value="0" step="0.01">
                        </div>
                        <div>
                            <label for="loopEndSlider">End: <span id="loopEndValue">0.00</span>s</label>
                            <input type="range" id="loopEndSlider" min="0" max="100" value="100" step="0.01">
                        </div>
                    </div>
                </div>
                <button id="applyLoopBtn">Apply Loop</button>
            </div>
        `;

        // Create keyboard binding container
        const keyboardSection = document.createElement('section');
        keyboardSection.className = 'keyboard-binding';
        keyboardSection.innerHTML = `
            <h2>Keyboard Binding</h2>
            <div class="binding-controls">
                <p>Select a sample and press a key to bind it</p>
                <div class="current-binding">
                    <span>Current selection: </span>
                    <span id="currentSampleName">None</span>
                </div>
                <button id="clearBindingsBtn">Clear All Bindings</button>
            </div>
            <div id="keyboard" class="keyboard">
                <!-- Keyboard keys will be generated by JavaScript -->
            </div>
        `;

        // Add these sections to the main container
        const container = document.querySelector('.container');
        container.insertBefore(videoPlayerSection, document.querySelector('.visualization'));
        container.insertBefore(keyboardSection, document.querySelector('.visualization'));

        // Update elements object with new elements
        this.elements.videoPlayer = document.getElementById('videoPlayer');
        this.elements.loopStartSlider = document.getElementById('loopStartSlider');
        this.elements.loopEndSlider = document.getElementById('loopEndSlider');
        this.elements.loopStartValue = document.getElementById('loopStartValue');
        this.elements.loopEndValue = document.getElementById('loopEndValue');
        this.elements.applyLoopBtn = document.getElementById('applyLoopBtn');
        this.elements.keyboard = document.getElementById('keyboard');
        this.elements.currentSampleName = document.getElementById('currentSampleName');
        this.elements.clearBindingsBtn = document.getElementById('clearBindingsBtn');
    }

    /**
     * Set up all event listeners
     */
    setupEventListeners() {
        // Transport controls
        this.elements.playButton.addEventListener('click', () => this.togglePlay());
        this.elements.stopButton.addEventListener('click', () => this.stop());
        this.elements.tempoSlider.addEventListener('input', (e) => this.updateTempo(e.target.value));

        // File loading
        this.elements.dropZone.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.elements.dropZone.addEventListener('drop', (e) => this.handleDrop(e));
        this.elements.audioFileInput.addEventListener('change', (e) => this.handleFileSelect(e));

        // Layer controls
        this.elements.splitLayersBtn.addEventListener('click', () => this.splitIntoLayers());

        const soloButtons = document.querySelectorAll('.solo-btn');
        const muteButtons = document.querySelectorAll('.mute-btn');
        const volumeSliders = document.querySelectorAll('.volume-slider');

        soloButtons.forEach(btn => {
            btn.addEventListener('click', (e) => this.handleSolo(e));
        });

        muteButtons.forEach(btn => {
            btn.addEventListener('click', (e) => this.handleMute(e));
        });

        volumeSliders.forEach(slider => {
            slider.addEventListener('input', (e) => this.handleVolumeChange(e));
        });

        // Effects controls
        this.elements.filterFreqSlider.addEventListener('input', (e) => this.updateFilterFrequency(e.target.value));
        this.elements.reverbLevelSlider.addEventListener('input', (e) => this.updateReverbLevel(e.target.value));
        this.elements.delayTimeSlider.addEventListener('input', (e) => this.updateDelayTime(e.target.value));

        // Sequencer controls
        this.elements.clearSequencerBtn.addEventListener('click', () => this.clearSequencer());
        this.elements.stepsSelect.addEventListener('change', (e) => this.changeStepCount(e.target.value));

        // Loop controls
        this.elements.loopStartSlider.addEventListener('input', (e) => this.updateLoopStart(e.target.value));
        this.elements.loopEndSlider.addEventListener('input', (e) => this.updateLoopEnd(e.target.value));
        this.elements.applyLoopBtn.addEventListener('click', () => this.applyLoop());

        // Keyboard binding
        this.elements.clearBindingsBtn.addEventListener('click', () => this.clearKeyBindings());
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));

        // Initialize keyboard UI
        this.initKeyboardUI();
    }

    /**
     * Initialize the sequencer grid
     */
    initSequencerGrid() {
        const grid = this.elements.sequencerGrid;
        grid.innerHTML = '';

        // Create header row with step numbers
        const headerRow = document.createElement('div');
        headerRow.className = 'sequencer-row header-row';

        const emptyCell = document.createElement('div');
        emptyCell.className = 'sequencer-cell header-cell';
        headerRow.appendChild(emptyCell);

        for (let i = 0; i < this.totalSteps; i++) {
            const stepCell = document.createElement('div');
            stepCell.className = 'sequencer-cell header-cell';
            stepCell.textContent = i + 1;
            headerRow.appendChild(stepCell);
        }

        grid.appendChild(headerRow);
    }

    /**
     * Initialize the keyboard UI
     */
    initKeyboardUI() {
        const keyboard = this.elements.keyboard;
        keyboard.innerHTML = '';

        // Define the keys to display
        const keyRows = [
            ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
            ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';'],
            ['Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/']
        ];

        // Create key elements
        keyRows.forEach(row => {
            const keyRowElement = document.createElement('div');
            keyRowElement.className = 'key-row';

            row.forEach(key => {
                const keyElement = document.createElement('div');
                keyElement.className = 'key';
                keyElement.dataset.key = key;
                keyElement.textContent = key;

                keyElement.addEventListener('click', () => this.handleKeyClick(key));

                keyRowElement.appendChild(keyElement);
            });

            keyboard.appendChild(keyRowElement);
        });
    }

    /**
     * Add a sample row to the sequencer
     * @param {string} sampleId - The sample ID
     * @param {string} sampleName - The sample name to display
     */
    addSampleRow(sampleId, sampleName) {
        const rowId = `row-${sampleId}`;

        // Check if row already exists
        if (document.getElementById(rowId)) {
            return;
        }

        const row = document.createElement('div');
        row.className = 'sequencer-row';
        row.id = rowId;

        const labelCell = document.createElement('div');
        labelCell.className = 'sequencer-cell label-cell';
        labelCell.textContent = sampleName;
        row.appendChild(labelCell);

        for (let i = 0; i < this.totalSteps; i++) {
            const cell = document.createElement('div');
            cell.className = 'sequencer-cell';
            cell.dataset.step = i;
            cell.dataset.sample = sampleId;
            cell.addEventListener('click', (e) => this.toggleSequencerCell(e));
            row.appendChild(cell);
        }

        this.elements.sequencerGrid.appendChild(row);
    }

    /**
     * Add a sample to the sample list
     * @param {string} sampleId - The sample ID
     * @param {string} sampleName - The sample name to display
     * @param {string} type - The sample type ('audio' or 'video')
     */
    addSampleToList(sampleId, sampleName, type = 'audio') {
        const listItem = document.createElement('li');
        listItem.className = 'sample-item';
        listItem.dataset.id = sampleId;

        const sampleNameElement = document.createElement('span');
        sampleNameElement.className = 'sample-name';
        sampleNameElement.textContent = sampleName;

        const previewButton = document.createElement('button');
        previewButton.className = 'preview-btn';
        previewButton.textContent = 'Preview';
        previewButton.addEventListener('click', () => this.previewSample(sampleId));

        const bindButton = document.createElement('button');
        bindButton.className = 'bind-btn';
        bindButton.textContent = 'Bind';
        bindButton.addEventListener('click', () => this.selectSampleForBinding(sampleId, sampleName));

        listItem.appendChild(sampleNameElement);

        // Add type indicator
        const typeIndicator = document.createElement('span');
        typeIndicator.className = `type-indicator ${type}`;
        typeIndicator.textContent = type.toUpperCase();
        listItem.appendChild(typeIndicator);

        listItem.appendChild(previewButton);
        listItem.appendChild(bindButton);

        this.elements.sampleList.appendChild(listItem);

        // Store in loaded samples
        this.loadedSamples[sampleId] = {
            id: sampleId,
            name: sampleName,
            type: type
        };

        // Enable split layers button if we have at least one sample
        this.elements.splitLayersBtn.disabled = false;
    }

    /**
     * Toggle play/pause
     */
    togglePlay() {
        this.isPlaying = !this.isPlaying;

        if (this.isPlaying) {
            this.elements.playButton.textContent = 'Pause';
            if (this.callbacks.onPlay) this.callbacks.onPlay();
        } else {
            this.elements.playButton.textContent = 'Play';
            if (this.callbacks.onStop) this.callbacks.onStop();
        }
    }

    /**
     * Stop playback
     */
    stop() {
        this.isPlaying = false;
        this.elements.playButton.textContent = 'Play';
        this.currentStep = 0;

        // Remove current-step highlighting
        document.querySelectorAll('.sequencer-cell').forEach(cell => {
            cell.classList.remove('current-step');
        });

        if (this.callbacks.onStop) this.callbacks.onStop();
    }

    /**
     * Update tempo display
     * @param {number} value - The tempo value
     */
    updateTempo(value) {
        const tempo = parseInt(value);
        this.elements.tempoValue.textContent = tempo;

        if (this.callbacks.onTempoChange) this.callbacks.onTempoChange(tempo);
    }

    /**
     * Handle file drag over
     * @param {Event} event - The drag event
     */
    handleDragOver(event) {
        event.preventDefault();
        event.stopPropagation();
        this.elements.dropZone.classList.add('dragover');
    }

    /**
     * Handle file drop
     * @param {Event} event - The drop event
     */
    handleDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        this.elements.dropZone.classList.remove('dragover');

        const files = event.dataTransfer.files;
        if (this.callbacks.onFilesDrop) this.callbacks.onFilesDrop(files);
    }

    /**
     * Handle file select
     * @param {Event} event - The change event
     */
    handleFileSelect(event) {
        const files = event.target.files;
        if (this.callbacks.onFilesSelect) this.callbacks.onFilesSelect(files);
    }

    /**
     * Preview a sample
     * @param {string} sampleId - The sample ID
     */
    previewSample(sampleId) {
        if (this.callbacks.onSamplePreview) this.callbacks.onSamplePreview(sampleId);
    }

    /**
     * Split audio into layers
     */
    splitIntoLayers() {
        this.elements.layerControls.classList.remove('hidden');

        if (this.callbacks.onSplitLayers) this.callbacks.onSplitLayers();
    }

    /**
     * Handle solo button click
     * @param {Event} event - The click event
     */
    handleSolo(event) {
        const layerEl = event.target.closest('.layer');
        const layerId = layerEl.dataset.layer;

        // Toggle active state
        event.target.classList.toggle('active');

        if (this.callbacks.onLayerSolo) {
            this.callbacks.onLayerSolo(layerId, event.target.classList.contains('active'));
        }
    }

    /**
     * Handle mute button click
     * @param {Event} event - The click event
     */
    handleMute(event) {
        const layerEl = event.target.closest('.layer');
        const layerId = layerEl.dataset.layer;

        // Toggle active state
        event.target.classList.toggle('active');

        if (this.callbacks.onLayerMute) {
            this.callbacks.onLayerMute(layerId, event.target.classList.contains('active'));
        }
    }

    /**
     * Handle volume change
     * @param {Event} event - The input event
     */
    handleVolumeChange(event) {
        const layerEl = event.target.closest('.layer');
        const layerId = layerEl.dataset.layer;
        const volume = parseInt(event.target.value) / 100;

        if (this.callbacks.onLayerVolumeChange) {
            this.callbacks.onLayerVolumeChange(layerId, volume);
        }
    }

    /**
     * Update filter frequency
     * @param {number} value - The frequency value
     */
    updateFilterFrequency(value) {
        const freq = parseFloat(value);
        this.elements.filterFreqValue.textContent = `${Math.round(freq)} Hz`;

        if (this.callbacks.onFilterChange) this.callbacks.onFilterChange(freq);
    }

    /**
     * Update reverb level
     * @param {number} value - The reverb level
     */
    updateReverbLevel(value) {
        const level = parseFloat(value) / 100;
        this.elements.reverbValue.textContent = `${Math.round(level * 100)}%`;

        if (this.callbacks.onReverbChange) this.callbacks.onReverbChange(level);
    }

    /**
     * Update delay time
     * @param {number} value - The delay time
     */
    updateDelayTime(value) {
        const time = parseFloat(value);
        this.elements.delayTimeValue.textContent = `${time.toFixed(2)} s`;

        if (this.callbacks.onDelayChange) this.callbacks.onDelayChange(time);
    }

    /**
     * Toggle sequencer cell active state
     * @param {Event} event - The click event
     */
    toggleSequencerCell(event) {
        const cell = event.target;
        cell.classList.toggle('active');

        if (this.callbacks.onSequencerCellToggle) {
            this.callbacks.onSequencerCellToggle(
                cell.dataset.sample,
                parseInt(cell.dataset.step),
                cell.classList.contains('active')
            );
        }
    }

    /**
     * Clear sequencer pattern
     */
    clearSequencer() {
        const activeCells = this.elements.sequencerGrid.querySelectorAll('.sequencer-cell.active');
        activeCells.forEach(cell => {
            cell.classList.remove('active');
        });

        if (this.callbacks.onSequencerClear) this.callbacks.onSequencerClear();
    }

    /**
     * Change number of steps in sequencer
     * @param {number} steps - The number of steps
     */
    changeStepCount(steps) {
        this.totalSteps = parseInt(steps);
        this.currentStep = 0;
        this.initSequencerGrid();

        // Re-add sample rows
        Object.keys(this.loadedSamples).forEach(sampleId => {
            this.addSampleRow(sampleId, this.loadedSamples[sampleId].name);
        });

        if (this.callbacks.onStepsChange) this.callbacks.onStepsChange(this.totalSteps);
    }

    /**
     * Update loop start point
     * @param {number} value - The start point value
     */
    updateLoopStart(value) {
        const startTime = parseFloat(value);
        this.elements.loopStartValue.textContent = startTime.toFixed(2);

        // Ensure start is less than end
        const endTime = parseFloat(this.elements.loopEndSlider.value);
        if (startTime >= endTime) {
            this.elements.loopStartSlider.value = endTime - 0.01;
            this.elements.loopStartValue.textContent = (endTime - 0.01).toFixed(2);
        }
    }

    /**
     * Update loop end point
     * @param {number} value - The end point value
     */
    updateLoopEnd(value) {
        const endTime = parseFloat(value);
        this.elements.loopEndValue.textContent = endTime.toFixed(2);

        // Ensure end is greater than start
        const startTime = parseFloat(this.elements.loopStartSlider.value);
        if (endTime <= startTime) {
            this.elements.loopEndSlider.value = startTime + 0.01;
            this.elements.loopEndValue.textContent = (startTime + 0.01).toFixed(2);
        }
    }

    /**
     * Apply loop points to current sample
     */
    applyLoop() {
        const startTime = parseFloat(this.elements.loopStartSlider.value);
        const endTime = parseFloat(this.elements.loopEndSlider.value);

        // Get the currently selected sample (if any)
        const selectedSample = this.elements.videoPlayer.dataset.sampleId;

        if (selectedSample && this.callbacks.onLoopPointsChange) {
            this.callbacks.onLoopPointsChange(selectedSample, startTime, endTime);
        }
    }

    /**
     * Select a sample for keyboard binding
     * @param {string} sampleId - The sample ID
     * @param {string} sampleName - The sample name
     */
    selectSampleForBinding(sampleId, sampleName) {
        // Update current selection display
        this.elements.currentSampleName.textContent = sampleName;
        this.elements.currentSampleName.dataset.sampleId = sampleId;

        // Highlight the selected sample in the list
        const sampleItems = this.elements.sampleList.querySelectorAll('.sample-item');
        sampleItems.forEach(item => {
            item.classList.remove('selected');
            if (item.dataset.id === sampleId) {
                item.classList.add('selected');
            }
        });
    }

    /**
     * Handle key click for binding
     * @param {string} key - The key that was clicked
     */
    handleKeyClick(key) {
        const selectedSampleId = this.elements.currentSampleName.dataset.sampleId;

        if (selectedSampleId) {
            this.bindKeyToSample(key, selectedSampleId);
        } else {
            // If no sample is selected, try to play the bound sample
            this.triggerKeySound(key);
        }
    }

    /**
     * Handle keyboard key down event
     * @param {KeyboardEvent} event - The keydown event
     */
    handleKeyDown(event) {
        // Ignore if in an input field
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            return;
        }

        const key = event.key.toUpperCase();
        const keyElement = this.elements.keyboard.querySelector(`.key[data-key="${key}"]`);

        if (keyElement) {
            // Add active class for visual feedback
            keyElement.classList.add('active');

            // Remove active class after a short delay
            setTimeout(() => {
                keyElement.classList.remove('active');
            }, 100);

            const selectedSampleId = this.elements.currentSampleName.dataset.sampleId;

            if (selectedSampleId) {
                // If a sample is selected, bind it to this key
                this.bindKeyToSample(key, selectedSampleId);
            } else {
                // Otherwise, trigger the sound bound to this key
                this.triggerKeySound(key);
            }
        }
    }

    /**
     * Bind a key to a sample
     * @param {string} key - The key to bind
     * @param {string} sampleId - The sample ID to bind to the key
     */
    bindKeyToSample(key, sampleId) {
        const keyElement = this.elements.keyboard.querySelector(`.key[data-key="${key}"]`);

        if (keyElement) {
            // Update key element
            keyElement.classList.add('mapped');
            keyElement.dataset.boundSample = sampleId;

            // Store the sample name as title for hover
            const sampleName = this.loadedSamples[sampleId]?.name || sampleId;
            keyElement.title = `Bound to: ${sampleName}`;

            if (this.callbacks.onKeyBind) {
                this.callbacks.onKeyBind(key, sampleId);
            }
        }
    }

    /**
     * Trigger sound for a key
     * @param {string} key - The key to trigger
     */
    triggerKeySound(key) {
        const keyElement = this.elements.keyboard.querySelector(`.key[data-key="${key}"]`);

        if (keyElement && keyElement.dataset.boundSample) {
            const sampleId = keyElement.dataset.boundSample;

            if (this.callbacks.onKeyTrigger) {
                this.callbacks.onKeyTrigger(key, sampleId);
            }
        }
    }

    /**
     * Clear all key bindings
     */
    clearKeyBindings() {
        const mappedKeys = this.elements.keyboard.querySelectorAll('.key.mapped');

        mappedKeys.forEach(key => {
            key.classList.remove('mapped');
            delete key.dataset.boundSample;
            key.title = '';
        });

        if (this.callbacks.onClearBindings) {
            this.callbacks.onClearBindings();
        }
    }

    /**
     * Update the current step in the sequencer
     * @param {number} step - The current step
     */
    updateCurrentStep(step) {
        this.currentStep = step;

        // Remove highlight from all cells
        document.querySelectorAll('.sequencer-cell').forEach(cell => {
            cell.classList.remove('current-step');
        });

        // Add highlight to current step cells
        const stepCells = document.querySelectorAll(`.sequencer-cell[data-step="${step}"]`);
        stepCells.forEach(cell => {
            cell.classList.add('current-step');
        });

        return stepCells;
    }

    /**
     * Load a video into the video player
     * @param {string} sampleId - The sample ID
     * @param {HTMLVideoElement} videoElement - The video element
     * @param {Object} loopPoints - The loop points
     */
    loadVideoPlayer(sampleId, videoElement, loopPoints) {
        // Set the video source
        this.elements.videoPlayer.src = videoElement.src;
        this.elements.videoPlayer.dataset.sampleId = sampleId;

        // Update loop sliders
        const duration = videoElement.duration;

        // Update slider max values based on duration
        this.elements.loopStartSlider.max = duration;
        this.elements.loopEndSlider.max = duration;

        // Set current loop points
        if (loopPoints) {
            this.elements.loopStartSlider.value = loopPoints.start;
            this.elements.loopEndSlider.value = loopPoints.end;
            this.elements.loopStartValue.textContent = loopPoints.start.toFixed(2);
            this.elements.loopEndValue.textContent = loopPoints.end.toFixed(2);
        } else {
            this.elements.loopStartSlider.value = 0;
            this.elements.loopEndSlider.value = duration;
            this.elements.loopStartValue.textContent = '0.00';
            this.elements.loopEndValue.textContent = duration.toFixed(2);
        }
    }

    /**
     * Create track editor UI
     */
    createTrackEditor() {
        // Create track editor section if it doesn't exist
        if (!document.querySelector('.track-editor')) {
            const trackEditorSection = document.createElement('section');
            trackEditorSection.className = 'track-editor';
            trackEditorSection.innerHTML = `
                <h2>Track Editor</h2>
                <div class="editor-controls">
                    <button id="recordBtn" class="record-btn">Record</button>
                    <button id="stopRecordBtn" class="stop-record-btn" disabled>Stop Recording</button>
                    <span id="recordingStatus" class="recording-status">Not Recording</span>
                </div>
                <div class="timeline" id="timeline">
                    <!-- Tracks will be added here -->
                </div>
                <div class="timeline-controls">
                    <button id="playTimelineBtn">Play Timeline</button>
                    <button id="clearTimelineBtn">Clear Timeline</button>
                    <button id="exportBtn">Export</button>
                </div>
            `;

            // Add to container before visualization
            const container = document.querySelector('.container');
            container.insertBefore(trackEditorSection, document.querySelector('.visualization'));

            // Update elements object
            this.elements.recordBtn = document.getElementById('recordBtn');
            this.elements.stopRecordBtn = document.getElementById('stopRecordBtn');
            this.elements.recordingStatus = document.getElementById('recordingStatus');
            this.elements.timeline = document.getElementById('timeline');
            this.elements.playTimelineBtn = document.getElementById('playTimelineBtn');
            this.elements.clearTimelineBtn = document.getElementById('clearTimelineBtn');
            this.elements.exportBtn = document.getElementById('exportBtn');

            // Add event listeners
            this.elements.recordBtn.addEventListener('click', () => this.startRecording());
            this.elements.stopRecordBtn.addEventListener('click', () => this.stopRecording());
            this.elements.playTimelineBtn.addEventListener('click', () => this.playTimeline());
            this.elements.clearTimelineBtn.addEventListener('click', () => this.clearTimeline());
            this.elements.exportBtn.addEventListener('click', () => this.exportTimeline());
        }
    }

    /**
     * Start recording
     */
    startRecording() {
        this.elements.recordBtn.disabled = true;
        this.elements.stopRecordBtn.disabled = false;
        this.elements.recordingStatus.textContent = 'Recording...';
        this.elements.recordingStatus.classList.add('recording');

        if (this.callbacks.onStartRecording) {
            this.callbacks.onStartRecording();
        }
    }

    /**
     * Stop recording
     */
    stopRecording() {
        this.elements.recordBtn.disabled = false;
        this.elements.stopRecordBtn.disabled = true;
        this.elements.recordingStatus.textContent = 'Not Recording';
        this.elements.recordingStatus.classList.remove('recording');

        if (this.callbacks.onStopRecording) {
            this.callbacks.onStopRecording();
        }
    }

    /**
     * Add a recorded event to the timeline
     * @param {Object} event - The recorded event
     */
    addRecordedEvent(event) {
        // Create a track if it doesn't exist
        let track = this.elements.timeline.querySelector(`.track[data-sample="${event.sampleId}"]`);

        if (!track) {
            track = document.createElement('div');
            track.className = 'track';
            track.dataset.sample = event.sampleId;

            const trackLabel = document.createElement('div');
            trackLabel.className = 'track-label';
            trackLabel.textContent = this.loadedSamples[event.sampleId]?.name || event.sampleId;

            track.appendChild(trackLabel);
            this.elements.timeline.appendChild(track);
        }

        // Add clip to track
        const clip = document.createElement('div');
        clip.className = 'clip';
        clip.style.left = `${event.time * 100}px`;
        clip.style.width = `${event.duration * 100}px`;
        clip.dataset.time = event.time;
        clip.dataset.duration = event.duration;
        clip.dataset.sampleId = event.sampleId;

        // Add clip controls
        clip.innerHTML = `
            <div class="clip-handle left"></div>
            <div class="clip-content">${this.loadedSamples[event.sampleId]?.name || 'Clip'}</div>
            <div class="clip-handle right"></div>
        `;

        track.appendChild(clip);

        // Make clip draggable and resizable
        this.makeClipInteractive(clip);
    }

    /**
     * Make a clip draggable and resizable
     * @param {HTMLElement} clip - The clip element
     */
    makeClipInteractive(clip) {
        // Implement drag and resize functionality
        // This is a simplified version - a real implementation would be more complex

        let isDragging = false;
        let isResizingLeft = false;
        let isResizingRight = false;
        let startX = 0;
        let startLeft = 0;
        let startWidth = 0;

        const leftHandle = clip.querySelector('.clip-handle.left');
        const rightHandle = clip.querySelector('.clip-handle.right');

        // Left resize handle
        leftHandle.addEventListener('mousedown', (e) => {
            isResizingLeft = true;
            startX = e.clientX;
            startLeft = parseInt(clip.style.left) || 0;
            startWidth = parseInt(clip.style.width) || 0;
            e.stopPropagation();
        });

        // Right resize handle
        rightHandle.addEventListener('mousedown', (e) => {
            isResizingRight = true;
            startX = e.clientX;
            startWidth = parseInt(clip.style.width) || 0;
            e.stopPropagation();
        });

        // Clip dragging
        clip.addEventListener('mousedown', (e) => {
            if (!isResizingLeft && !isResizingRight) {
                isDragging = true;
                startX = e.clientX;
                startLeft = parseInt(clip.style.left) || 0;
            }
        });

        // Mouse move handler
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - startX;
                clip.style.left = `${Math.max(0, startLeft + dx)}px`;
            } else if (isResizingLeft) {
                const dx = e.clientX - startX;
                const newLeft = Math.max(0, startLeft + dx);
                const newWidth = Math.max(10, startWidth - dx);

                clip.style.left = `${newLeft}px`;
                clip.style.width = `${newWidth}px`;
            } else if (isResizingRight) {
                const dx = e.clientX - startX;
                clip.style.width = `${Math.max(10, startWidth + dx)}px`;
            }
        });

        // Mouse up handler
        document.addEventListener('mouseup', () => {
            if (isDragging || isResizingLeft || isResizingRight) {
                // Update clip data attributes
                clip.dataset.time = parseInt(clip.style.left) / 100;
                clip.dataset.duration = parseInt(clip.style.width) / 100;

                // Trigger callback
                if (this.callbacks.onClipEdit) {
                    this.callbacks.onClipEdit({
                        sampleId: clip.dataset.sampleId,
                        time: parseFloat(clip.dataset.time),
                        duration: parseFloat(clip.dataset.duration)
                    });
                }
            }

            isDragging = false;
            isResizingLeft = false;
            isResizingRight = false;
        });
    }

    /**
     * Play the timeline
     */
    playTimeline() {
        if (this.callbacks.onPlayTimeline) {
            this.callbacks.onPlayTimeline();
        }
    }

    /**
     * Clear the timeline
     */
    clearTimeline() {
        this.elements.timeline.innerHTML = '';

        if (this.callbacks.onClearTimeline) {
            this.callbacks.onClearTimeline();
        }
    }

    /**
     * Export the timeline
     */
    exportTimeline() {
        if (this.callbacks.onExportTimeline) {
            this.callbacks.onExportTimeline();
        }
    }

    /**
     * Set a callback function
     * @param {string} callbackName - The name of the callback
     * @param {Function} callback - The callback function
     */
    setCallback(callbackName, callback) {
        if (this.callbacks.hasOwnProperty(callbackName)) {
            this.callbacks[callbackName] = callback;
        } else {
            console.warn(`Unknown callback: ${callbackName}`);
        }
    }
}

// Export the UI class
export default UI;
